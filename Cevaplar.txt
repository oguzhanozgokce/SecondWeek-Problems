Temel Türler & Null Güvenliği

------------------------------------------------------------------------------------------------------------------------------------
1-) val ile var arasındaki fark nedir?

-var "mutable" (değiştirilebilir) değişkenler için kullanılır.
-val "immutable" (değiştirilemez) değişkenler için kullanılır
-val için genelde inMutable degisken denir. Yani degeri degistirilemez. Fakat bu yanlis bir tanimdir.
-Dogrusu read-only degiskenlerdir. Yani ilk deger atamasından sonra tekrar deger atanamaz.

------------------------------------------------------------------------------------------------------------------------------------
2-) Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

-val gibi davranmasını saglamak icin private set kullanilir.

class User {
    var isMale = true
        private set // isMale değişkeninin değeri sınıf dışından değiştirilemez.

    fun updateGender(isMale: Boolean) {
        // Belirli koşullar doğrultusunda cinsiyet güncellemesi yapılabilir.
        // Örneğin, kullanıcıdan onay alındıktan sonra cinsiyet güncelleniyor olabilir.
        if (checkUserConsent()) { // checkUserConsent, kullanıcının onayını kontrol eden kurgusal bir metod.
            this.isMale = isMale
        }
    }

    private fun checkUserConsent(): Boolean {
        // Kullanıcı onayı kontrolü yapılır.
        // Gerçek bir uygulamada, bu, kullanıcı arayüzünden bir onay almayı gerektirebilir.
        return true // Örnek amaçlı her zaman true döndürüldü.
    }
}
-Bu senaryoda, User sinifimiz var ve bu sinifin kullanicalarin cinsiyetini(isMale) tutmasını istiyoruz.
  Ancak, kullanici cinsiyetini sinif disindan rastgele degistirebilmelerini istemiyoruz.
-Bunun yerine, cinsiyet degiskenini belirli bir metot ile belirli kosullar altında degistirilmesini istiyoruz.
  Bu, kullanıcının cinsiyetinin yanlışlıkla değiştirilmesini önler ve veri bütünlüğünü korur.

-Bu senaryoda, isMale değişkeni sınıf dışından doğrudan değiştirilemez, ancak updateGender metodunu kullanarak kontrol edilen bir şekilde güncellenebilir.
-Bu yaklaşım, sınıfın nasıl kullanılacağı üzerinde daha fazla kontrol sağlar ve yanlış kullanımı önler.

------------------------------------------------------------------------------------------------------------------------------------
3-) "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

-Immutable: Değiştirilemez anlamına gelir. Yani, bir kez atanan değer değiştirilemez.
-ReadOnly: Bir degiskenin ve nesnenin sadece okunabilir oldugunu belirtir.ancak programın çalışması sırasında değiştirilemediği anlamına gelir.
    Ancak, bu, nesnenin içindeki diğer nesnelerin değiştirilemez olduğu anlamına gelmez.

-> val ile tanımlanan bir değişkene atanan nesne, değişkenin kendisi yeniden atanamaz; yani değişkenin referansı değişmez.
    Ancak, bu atanan nesnenin kendisi değişmez (immutable) olmak zorunda değildir.
    Örnek: val ile liste tanımlandığında, bu liste değişkene başka bir liste atanamaz, fakat listeye eleman eklemek veya listeden eleman çıkarmak mümkündür.
        Bu durumda listenin referansı değişmez(salt okunur), fakat listenin içeriği değişebilir.

------------------------------------------------------------------------------------------------------------------------------------
4-) "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

-Degiskenin tipini belirtmeden, degiskenin degerine gore IDE'nin  tipini belirlemesidir.
-Degiskenin tipini belirtmek kesin olarak gereklidir:

    - Degiskenin ilk degeri yoksa, IDE degiskenin tipini belirleyemez.
             var isim: String

    - Fonksiyonların parametreleri ve dönüş değerleri için tip belirtmek genellikle zorunludur
            fun topla(a: Int, b: Int): Int {
                return a + b
            }
    - Genel (Generic) Tip Parametreleri

------------------------------------------------------------------------------------------------------------------------------------
5-) Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

 * Class gibi gözüken primitive tiplerde özel optimazyonla byte code cevriliyor.
 * val age: Int = 25  arka planda java da int e cevriliyor.
 * Not: Bu tip dönüsümü degildir.

------------------------------------------------------------------------------------------------------------------------------------
6-) "Tip Güvenliği" (Type Safety) kavramını açıklayın.

-Programlama dilinin hatalı veya uyumsuz tip kullanımını önleyerek çalışma zamanı hatalarını azaltma yeteneğidir.

------------------------------------------------------------------------------------------------------------------------------------
7-) Bir değişkeni nullable yapmak için ne yapmalıyız?

-Bir degiskene null deger atamak icin ? isareti kullanilir.
-Eger bir degiskene tip verilmez e direkt null deger atanirsa, IDE Type Inference yapar ve degiskenin degerini Nothing? olarak belirler.
    val name: String? = null

------------------------------------------------------------------------------------------------------------------------------------
8-) "Null Güvenliği" (Null Safety) kavramını açıklayın.
-(Null Safety), bir programlama dilinin null referans hatalarını önleme mekanizmasını ifade eder.
-Null referans hatası, bir değişkenin null değerini referans alması ve bu değişken üzerinde bir işlem yapılmaya çalışıldığında ortaya çıkar.
-Bu tür hatalar, çalışma zamanında çökme gibi beklenmedik davranışlara yol açabilir

------------------------------------------------------------------------------------------------------------------------------------
9-) Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?
-Eger bir degiskene tip verilmez e direkt null deger atanirsa, IDE Type Inference yapar ve degiskenin degerini Nothing? olarak belirler.
val number : Nothing? = null    // Nothing?
    val sum = null     // Nothing?

------------------------------------------------------------------------------------------------------------------------------------
10-) İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

-Nullable olması bellekte daha fazla alan kaplar. Çünkü null bilgisini tutacağı bir alan olmalıdır.
    val number: Int? = null  // nullable
    val number: Int = null   // null alamaz

------------------------------------------------------------------------------------------------------------------------------------
11-) Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

    -Bir değişkenin null olması durumunda, bu değişkenin bellekte bir referansı olacaktır.
    -Bu referans, null değerini temsil eder ve bu referansın bellekte bir alan kapladığını söyleyebiliriz.

------------------------------------------------------------------------------------------------------------------------------------
12-) Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

    val result : Int? = 0
    result?.plus(5)
    result!!.plus(5)

   *  result?.plus(5)  - > ?. anlamı: result degeri Null olabilir ama sonradan baska deger atandıysa bu kod calıssın.
   *                          eger result null ise kodu calıstırmaz.
   *  result!!.plus(5) - > anlamı: result degeri null olamayacagını garanti ederiz.  Null olursa exception fırlatır.
   *
   *  Kritik islerde !! kullanmak gerekir.(Banka kredi hesaplaması)

------------------------------------------------------------------------------------------------------------------------------------

SAYILAR

1)Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

     *          Type    |       Size(Bits)        |       Min Value         |       Max Value
     *          ---------------------------------------------------------------------------------
     *          Byte    |       8                   |       -128                |       127
     *          Short   |       16                  |       -32768              |       32767
     *          Int     |       32                  |       -2_147_483_648       |       2_147_483_647
     *          Long    |       64                  |       -9_223_372_036_854_775_808       |       9_223_372_036_854_775_807
     *          Float   |       32                  |       1.4E-45             |       3.4028235E38
     *          Double  |       64                  |       4.9E-324            |       1.7976931348623157E308

    Bu aralıkların önemi: Bellek yönetimi ve performans açısından önemlidir.
    Örneğin, bir değişkenin tipi için en küçük veri tipini seçmek, bellek kullanımını azaltır ve performansı artırır.
    Veri tipini belirtmezsek IDE genellikle Int tipini seçer.

------------------------------------------------------------------------------------------------------------------------------------
2)Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

     -Degiskene tip belirtimi yapılmazsa IDE Type Inference yapar ve degiskenin degerine gore tipini belirler.
     -Default olarak Int tipini secer.
        val number = 25  // Int

------------------------------------------------------------------------------------------------------------------------------------
3)Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?

    -Nedeni sayılsa değişkenlerin tanımlanmasında kullanılan harflerin karışıklığa sebep olmamasıdır.
    -Örneğin, Long değişkenlerde küçük l harfi kullanılmaz çünkü küçük l harfi, sayı 1'e benzer ve karışıklığa sebep olabilir.
        val bigNumber = 123456789L
------------------------------------------------------------------------------------------------------------------------------------
4)Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

    -Tek duyarlıklılık(Single precision) için, kayan nokta sayısını temsil etmek üzere 32 bit kullanılır.
    -Çift duyarlıklılık(Double precision) için kayan nokta sayısını temsil etmek üzere 64 bit kullanılır.

    val singlePrecisionNumber: Float = 3.14f
    val doublePrecisionNumber: Double = 3.141592653589793

------------------------------------------------------------------------------------------------------------------------------------
5)Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?


6)Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?
7)Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?
8)Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?
9)"Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?
10)Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?
11)== ile neyi karşılaştırırız? === ile neyi karşılaştırırız?
12)=== operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?
13)Sayısal değişkenlerde hangi matematiksel operatörler kullanılabilir?
14)Sayısal değişkenlerde hangi karşılaştırma operatörleri kullanılabilir?
15)Bit düzeyinde operatörler (Bitwise operators) nelerdir? Ne amaçla kullanılır? Kotlin'de bunları nasıl kullanabilirsiniz?
16)Kotlin'de büyük sayılarla çalışırken hangi ek türlerden yararlanılır ve bu türlerin sınırları nelerdir?
17)Double ve Float değişkenler kullanılırken "yuvarlama" davranışı nasıldır? Bu nasıl değiştirilebilir?
